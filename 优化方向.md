要想拿到更好的性能，可以考虑：

减少 Python 循环/列表拼装：提前预分配平铺 buffer（可按 prefix-sum 构建 offset），避免大量 append/extend + cat。
更紧凑的元信息：meta 可以拆成多个并行张量或小整数类型，减少带宽和 cat/reshape 开销。
通信形态优化：当前两次 all_to_all_single 分发数据/元信息，逻辑没问题，但可以尝试合并元信息（打包成 struct、用更小 dtype），或对 token 做排序/分组以提升对齐和 coalescing。
容量与 padding：基线没做 capacity 控制，max_recv 直接乘 world_size，内存和写入浪费；可以引入 capacity 上限并在发送前裁剪/重排。
异步与重叠：用 all_to_all_single(..., async_op=True)，同时准备下一批/计算，增加 overlap。
向量化本地落桶：落桶时每条 token 一次赋值，可以尝试用 index_put/scatter 等张量操作批量搬运（需注意对 autograd 的影响）。
dtype/精度：如果允许，传输和落桶时用更小 dtype（如 fp16/bf16），减少带宽，再在聚合前转回目标 dtype。

```
cd /Users/tim/code/zomi/amd_distributed
cat > test_single.py <<'PY'
import torch
from all2all.reference import generate_input, check_implementation
from all2all.submission import custom_kernel

args = dict(num_experts=8, experts_per_token=2, hidden_dim=16,
            max_num_tokens=4, seed=123, rank=0, world_size=1)
data = generate_input(**args)
ok, msg = check_implementation(data, custom_kernel(data))
print("pass?", ok, msg)
PY

python test_single.py
```

```
cd /Users/tim/code/zomi/amd_distributed
cat > test_multi.py <<'PY'
import os, torch, torch.distributed as dist
from all2all.reference import generate_input, check_implementation
from all2all.submission import custom_kernel

rank = int(os.environ["LOCAL_RANK"])
world = int(os.environ["WORLD_SIZE"])
dist.init_process_group("nccl", init_method="env://", rank=rank, world_size=world, device_id=rank)

args = dict(num_experts=8, experts_per_token=2, hidden_dim=16,
            max_num_tokens=4, seed=123, rank=rank, world_size=world)
data = generate_input(**args)
ok, msg = check_implementation(data, custom_kernel(data))
print(f"rank{rank} pass? {ok} {msg}")
dist.destroy_process_group()
PY

torchrun --standalone --nproc_per_node=2 test_multi.py
```

eval:
```
cd /Users/tim/code/zomi/amd_distributed
cat > test_eval_local.py <<'PY'
import multiprocessing
from all2all.task import TestSpec  # 只是类型引用
from eval import get_test_cases, run_testing, PopcornOutput
from all2all import submission  # 触发 custom_kernel 注册
import os, sys

tests = get_test_cases("all2all/task.yml", seed=42)
# 只跑 correctness，不需要 POPCORN_FD：把日志输出到 stdout
logger = PopcornOutput(sys.stdout.fileno())
with multiprocessing.get_context("spawn").Pool(len(tests[0].args.get("world_size",1) if isinstance(tests[0].args.get("world_size", None), int) else [1])) as pool:
    rc = run_testing(logger, pool, tests)
sys.exit(rc)
PY

python test_eval_local.py
```
run_testing 会逐条 test 用 custom_kernel vs reference 对比，全部 pass 时 rc=0。